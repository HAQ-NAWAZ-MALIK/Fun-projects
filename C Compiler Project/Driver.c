#include "interface.h"
#include "keyword_table.h"
#include "lexer.h"
#include "parser.h"
#include "nary_tree.h"
#include "ast.h"
#include "printer.h"
#include "error_handler.h"
#include "symbol_table.h"
#include "semantic_analyzer.h"
#include "type_checker.h"
#include "code_gen.h"
#include <time.h>

int main(int argc, char* argv[]) {
    int userOption;

    if(argc != 3) {
        printf("Insufficient arguments provided\n");
        return 0;
    }

    printf("\n\n");
    printf("-------Compiler Project Group 27--------\n");

    printf("LEVEL 4: ");
    printf("Symbol Table has been constructed / Type checking and Semantic analysis modules are functional\n");
    printf("------ Status --------\n");
    printf("Lexer and parser have been implemented\n");
    printf("First and follow sets have been automated\n");
    printf("Symbol Table has been constructed / Type checking and Semantic analysis modules are functional\n");
    printf("Code generation is partially implemented. A test case (main0.txt) works for small inputs\n");
    printf("Commands used to execute the .asm file:\n");
    printf("nasm -felf64 code.asm && gcc code.o && ./a.out\n");
    printf("----------------------\n\n");

    printf("Enter 0 to exit\n");
    printf("Enter 1 to print the list of tokens generated by the lexer\n");
    printf("Enter 2 to print the parse tree\n");
    printf("Enter 3 to print the AST (Ensure the input creates a valid AST)\n");
    printf("Enter 4 to calculate the compression ratio\n");
    printf("Enter 5 to print the symbol table\n");
    printf("Enter 6 to print global variable information\n");
    printf("Enter 7 to print function information\n");
    printf("Enter 8 to print all records\n");
    printf("Enter 9 to verify program correctness\n");
    printf("Enter 10 to generate NASM code\n");

    while(1) {
        scanf("%d", &userOption);

        switch(userOption) {
            case 0:
                return 0;
            case 1:
                printf("Printing token list\n");
                printf("--------\n");
                int f = open(argv[1], O_RDONLY);
                initializeLexer(f);
                Token* t;
                while((t = getToken()) != NULL) {
                    printf("%s        %s        %d\n", getTerminal(t->TOKEN_NAME), t->LEXEME, t->LINE_NO);
                }
                close(f);
                printf("\nFinished printing token list\n");
                break;
            case 2:
                printf("Parsing input source code\n");
                printf("--------\n");
                Grammar* g = extractGrammar();
                FirstAndFollow* fafl = computeFirstAndFollowSets(g);
                ParsingTable* pTable = initialiseParsingTable();
                createParseTable(fafl, pTable);
                ParseTree* pt = parseInputSourceCode(argv[1], pTable, fafl);
                printParseTree(pt, NULL);
                printf("\nFinished parsing input source code\n");
                break;
            case 3:
                printf("Printing AST in level format\n");
                printf("Each node will have its parent printed\n");
                Grammar* g = extractGrammar();
                FirstAndFollow* fafl = computeFirstAndFollowSets(g);
                ParsingTable* pTable = initialiseParsingTable();
                createParseTable(fafl, pTable);
                ParseTree* pt = parseInputSourceCode(argv[1], pTable, fafl);
                if(getErrorStatus() == 1) {
                    printf("Parsing or lexical analysis errors found, not proceeding to AST construction\n");
                    break;
                }
                AST* ast = constructAST(pt);
                levelPrint(ast->root);
                printf("Completed printing AST\n");
                break;
            case 4:
                Grammar* g = extractGrammar();
                FirstAndFollow* fafl = computeFirstAndFollowSets(g);
                ParsingTable* pTable = initialiseParsingTable();
                createParseTable(fafl, pTable);
                ParseTree* pt = parseInputSourceCode(argv[1], pTable, fafl);
                if(getErrorStatus() == 1) {
                    printf("Parsing or lexical analysis errors found, not proceeding to AST construction\n");
                    break;
                }
                AST* ast = constructAST(pt);
                printf("Parse tree nodes: %d, Memory: %d Bytes\n", getParseTreeNodeCount(), getParseTreeMemory());
                printf("AST nodes: %d, Memory: %d Bytes\n", getASTNodeCount(), getASTMemory());
                float compression = (100 * ((float)getParseTreeMemory() - (float)getASTMemory())) / ((float)getParseTreeMemory());
                printf("Compression: %f\n", compression);
                break;
            case 5:
                Grammar* g = extractGrammar();
                FirstAndFollow* fafl = computeFirstAndFollowSets(g);
                ParsingTable* pTable = initialiseParsingTable();
                createParseTable(fafl, pTable);
                ParseTree* pt = parseInputSourceCode(argv[1], pTable, fafl);
                if(getErrorStatus() == 1) {
                    printf("Parsing or lexical analysis errors found, not proceeding to AST construction\n");
                    break;
                }
                AST* ast = constructAST(pt);
                ErrorList* els = initializeErrorList();
                SymbolTable* st = constructSymbolTable(ast, els);
                captureErrors(ast, els);
                printSymbolTable(st, 1);
                break;
            case 6:
                Grammar* g = extractGrammar();
                FirstAndFollow* fafl = computeFirstAndFollowSets(g);
                ParsingTable* pTable = initialiseParsingTable();
                createParseTable(fafl, pTable);
                ParseTree* pt = parseInputSourceCode(argv[1], pTable, fafl);
                if(getErrorStatus() == 1) {
                    printf("Parsing or lexical analysis errors found, not proceeding to AST construction\n");
                    break;
                }
                AST* ast = constructAST(pt);
                ErrorList* els = initializeErrorList();
                SymbolTable* st = constructSymbolTable(ast, els);
                captureErrors(ast, els);
                printGlobals(st);
                break;
            case 7:
                Grammar* g = extractGrammar();
                FirstAndFollow* fafl = computeFirstAndFollowSets(g);
                ParsingTable* pTable = initialiseParsingTable();
                createParseTable(fafl, pTable);
                ParseTree* pt = parseInputSourceCode(argv[1], pTable, fafl);
                if(getErrorStatus() == 1) {
                    printf("Parsing or lexical analysis errors found, not proceeding to AST construction\n");
                    break;
                }
                AST* ast = constructAST(pt);
                ErrorList* els = initializeErrorList();
                SymbolTable* st = constructSymbolTable(ast, els);
                captureErrors(ast, els);
                printFunctions(st);
                break;
            case 8:
                Grammar* g = extractGrammar();
                FirstAndFollow* fafl = computeFirstAndFollowSets(g);
                ParsingTable* pTable = initialiseParsingTable();
                createParseTable(fafl, pTable);
                ParseTree* pt = parseInputSourceCode(argv[1], pTable, fafl);
                if(getErrorStatus() == 1) {
                    printf("Parsing or lexical analysis errors found, not proceeding to AST construction\n");
                    break;
                }
                AST* ast = constructAST(pt);
                ErrorList* els = initializeErrorList();
                SymbolTable* st = constructSymbolTable(ast, els);
                captureErrors(ast, els);
                printRecords(st);
                break;
            case 9:
                clock_t start_time, end_time;
                double total_CPU_time, total_CPU_time_in_seconds;
                start_time = clock();
                Grammar* g = extractGrammar();
                FirstAndFollow* fafl = computeFirstAndFollowSets(g);
                ParsingTable* pTable = initialiseParsingTable();
                createParseTable(fafl, pTable);
                ParseTree* pt = parseInputSourceCode(argv[1], pTable, fafl);
                if(getErrorStatus() == 1) {
                    printf("Parsing or lexical analysis errors found, not proceeding to AST construction\n");
                    break;
                } else {
                    AST* ast = constructAST(pt);
                    ErrorList* els = initializeErrorList();
                    SymbolTable* st = constructSymbolTable(ast, els);
                    captureErrors(ast, els);
                    printf("----PRINTING ERRORS-----\n");
                    printErrors(els);
                }
                end_time = clock();
                total_CPU_time = (double)(end_time - start_time);
                total_CPU_time_in_seconds = total_CPU_time / CLOCKS_PER_SEC;
                printf("Calculated time: %f\n", total_CPU_time);
                printf("Calculated time in seconds: %f\n", total_CPU_time_in_seconds);
                break;
            case 10:
                Grammar* g = extractGrammar();
                FirstAndFollow* fafl = computeFirstAndFollowSets(g);
                ParsingTable* pTable = initialiseParsingTable();
                createParseTable(fafl, pTable);
                ParseTree* pt = parseInputSourceCode(argv[1], pTable, fafl);
                if(getErrorStatus() == 1) {
                    printf("Parsing or lexical analysis errors found, not proceeding to AST construction\n");
                    break;
                } else {
                    AST* ast = constructAST(pt);
                    ErrorList* els = initializeErrorList();
                    SymbolTable* st = constructSymbolTable(ast, els);
                    captureErrors(ast, els);
                    printf("----PRINTING ERRORS-----\n");
                    printErrors(els);
                    if(els->head != NULL) {
                        printf("Semantic analysis errors found, not proceeding to code generation\n");
                        break;
                    }
                    FILE* f = fopen(argv[2], "w");
                    codeGeneration(ast, st, f);
                    printf("Completed code generation\n");
                }
                break;
            default:
                continue;
        }
    }
}
